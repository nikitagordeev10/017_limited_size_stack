# Платформа: ulearn
## Курс: Основы программирования
### Тема: 15 Очереди, стеки, дженерики
#### Практика «Limited Size Stack»
##### Решено 01 апреля 2023 в 15:44

В этой задаче реализован стек ограниченного размера. Этот стек работает как обычный стек, однако при превышении максимального размера удаляет самый глубокий элемент в стеке. Таким образом в стеке всегда будет ограниченное число элементов.

Вот пример работы такого стека с ограничением в 2 элемента:
```
// сначала стек пуст
stack.Push(10); // в стеке 10
stack.Push(20); // в стеке 10, 20
stack.Push(30); // в стеке 20, 30
stack.Push(40); // в стеке 30, 40
stack.Pop(); // возвращает 40, в стеке остаётся 30
stack.Pop(); // возвращает 30, стек после этого пуст
```

Операция Push должна иметь сложность O(1), то есть никак не зависеть от размера стека.

Реализуем класс LimitedSizeStack. Отладим его реализацию с помощью тестов в классе LimitedSizeStack_should. Проверим эффективность операции Push с помощью теста из класса LimitedSizeStack_PerformanceTest.

У каждой коллекции в C# доступен метод расширения Last(). Однако, работает он за O(1) только для коллекций, реализующих интерфейс IList (список с доступом к элементам по индексу). Для остальных коллекций он работает за O(N), перебирая её элементы до конца. 

Класс ListModel — в нём реализована логика работы кнопок в приложении.

Реализуем методы Undo и CanUndo. Для этого нужно хранить историю последних undoLimit действий удаления/добавления. Используем для этого класс LimitedSizeStack из прошлой задачи.

Метод Undo отменяет последнее действие из истории.
Метод CanUndo возвращает true, если на данный момент история действий не пуста, то есть если вызов Undo будет корректным. Иначе метод должен вернуть false.
Проверим корректность решения на модульных тестах из класса ListModel_Should и ListModel_PerformanceTest.